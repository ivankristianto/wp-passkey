{"version":3,"file":"index-4a4b01c0.js","sources":["../../../node_modules/@simplewebauthn/browser/dist/bundle/index.js"],"sourcesContent":["/* [@simplewebauthn/browser@7.4.0] */\nfunction utf8StringToBuffer(value) {\n    return new TextEncoder().encode(value);\n}\n\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n\nfunction browserSupportsWebAuthn() {\n    return (window?.PublicKeyCredential !== undefined && typeof window.PublicKeyCredential === 'function');\n}\n\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports,\n    };\n}\n\nfunction isValidDomain(hostname) {\n    return (hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n\nclass WebAuthnError extends Error {\n    code;\n    constructor({ message, code, cause, name, }) {\n        super(message, { cause });\n        this.name = name ?? cause.name;\n        this.code = code;\n    }\n}\n\nfunction identifyRegistrationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Registration ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (publicKey.authenticatorSelection?.requireResidentKey === true) {\n            return new WebAuthnError({\n                message: 'Discoverable credentials were required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',\n                cause: error,\n            });\n        }\n        else if (publicKey.authenticatorSelection?.userVerification === 'required') {\n            return new WebAuthnError({\n                message: 'User verification was required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        return new WebAuthnError({\n            message: 'The authenticator was previously registered',\n            code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',\n            cause: error\n        });\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter(param => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',\n                cause: error,\n            });\n        }\n        return new WebAuthnError({\n            message: 'No available authenticator supported any of the specified pubKeyCredParams algorithms',\n            code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error\n            });\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rp.id}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError({\n                message: 'User ID was not between 1 and 64 characters',\n                code: 'ERROR_INVALID_USER_ID_LENGTH',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new credential',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nclass WebAuthnAbortService {\n    controller;\n    createNewAbortSignal() {\n        if (this.controller) {\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n}\nconst webauthnAbortService = new WebAuthnAbortService();\n\nconst attachments = ['cross-platform', 'platform'];\nfunction toAuthenticatorAttachment(attachment) {\n    if (!attachment) {\n        return;\n    }\n    if (attachments.indexOf(attachment) < 0) {\n        return;\n    }\n    return attachment;\n}\n\nasync function startRegistration(creationOptionsJSON) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n        ...creationOptionsJSON,\n        challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n        user: {\n            ...creationOptionsJSON.user,\n            id: utf8StringToBuffer(creationOptionsJSON.user.id),\n        },\n        excludeCredentials: creationOptionsJSON.excludeCredentials?.map(toPublicKeyCredentialDescriptor),\n    };\n    const options = { publicKey };\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(options));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let transports = undefined;\n    if (typeof response.getTransports === 'function') {\n        transports = response.getTransports();\n    }\n    let responsePublicKeyAlgorithm = undefined;\n    if (typeof response.getPublicKeyAlgorithm === 'function') {\n        responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();\n    }\n    let responsePublicKey = undefined;\n    if (typeof response.getPublicKey === 'function') {\n        const _publicKey = response.getPublicKey();\n        if (_publicKey !== null) {\n            responsePublicKey = bufferToBase64URLString(_publicKey);\n        }\n    }\n    let responseAuthenticatorData;\n    if (typeof response.getAuthenticatorData === 'function') {\n        responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            transports,\n            publicKeyAlgorithm: responsePublicKeyAlgorithm,\n            publicKey: responsePublicKey,\n            authenticatorData: responseAuthenticatorData,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n\nfunction bufferToUTF8String(value) {\n    return new TextDecoder('utf-8').decode(value);\n}\n\nasync function browserSupportsWebAuthnAutofill() {\n    const globalPublicKeyCredential = window.PublicKeyCredential;\n    return (globalPublicKeyCredential.isConditionalMediationAvailable !== undefined &&\n        globalPublicKeyCredential.isConditionalMediationAvailable());\n}\n\nfunction identifyAuthenticationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Authentication ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nasync function startAuthentication(requestOptionsJSON, useBrowserAutofill = false) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (requestOptionsJSON.allowCredentials?.length !== 0) {\n        allowCredentials = requestOptionsJSON.allowCredentials?.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...requestOptionsJSON,\n        challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n        allowCredentials,\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete*='webauthn']\");\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with `\"webauthn\"` in its `autocomplete` attribute was detected');\n        }\n        options.mediation = 'conditional';\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(options));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToUTF8String(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n\nasync function platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return false;\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport { browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };\n"],"names":["utf8StringToBuffer","value","bufferToBase64URLString","buffer","bytes","str","charCode","base64URLStringToBuffer","base64URLString","base64","padLength","padded","binary","i","browserSupportsWebAuthn","toPublicKeyCredentialDescriptor","descriptor","id","isValidDomain","hostname","WebAuthnError","message","code","cause","name","__publicField","identifyRegistrationError","error","options","_a","_b","publicKey","param","effectiveDomain","WebAuthnAbortService","abortError","newController","webauthnAbortService","attachments","toAuthenticatorAttachment","attachment","startRegistration","creationOptionsJSON","credential","err","rawId","response","type","transports","responsePublicKeyAlgorithm","responsePublicKey","_publicKey","responseAuthenticatorData","bufferToUTF8String","browserSupportsWebAuthnAutofill","globalPublicKeyCredential","identifyAuthenticationError","startAuthentication","requestOptionsJSON","useBrowserAutofill","allowCredentials","userHandle"],"mappings":"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","x_google_ignoreList":[0]}